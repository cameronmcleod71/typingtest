# Example usage:
maze = Maze(20, 20)
generator = Generator(maze)
generator.generate()
print(maze)

solver = Solver(maze)
if solver.solve():
    print("Path found:")
    for cell in solver.path:
        print(f"({cell.x}, {cell.y})", end=" ")
else:
    print("No path found.")

class Generator:
    def __init__(self, maze):
        self.maze = maze
        self.current_cell = maze.get_cell(0, 0)
        self.current_cell.visited = True
        self.stack = [self.current_cell]

    def generate(self):
        while self.stack:
            neighbors = []
            for direction in ["N", "E", "S", "W"]:
                neighbor = self.get_neighbor(direction)
                if neighbor is not None and not neighbor.visited:
                    neighbors.append((direction, neighbor))

            if not neighbors:
                self.current_cell = self.stack.pop()
            else:
                direction, neighbor = random.choice(neighbors)
                self.remove_wall(self.current_cell, neighbor, direction)
                neighbor.visited = True
                self.stack.append(neighbor)
                self.current_cell = neighbor

    def remove_wall(self, cell1, cell2, direction):
        if direction == "N":
            cell1.walls["N"] = False
            cell2.walls["S"] = False
        elif direction == "E":
            cell1.walls["E"] = False
            cell2.walls["W"] = False
        elif direction == "S":
            cell1.walls["S"] = False
            cell2.walls["N"] = False
        elif direction == "W":
            cell1.walls["W"] = False
            cell2.walls["E"] = False

    def get_neighbor(self, direction):
        if direction == "N":
            return self.maze.get_cell(self.current_cell.x, self.current_cell.y - 1)
        elif direction == "E":
            return self.maze.get_cell(self.current_cell.x + 1, self.current_cell.y)
        elif direction == "S":
            return self.maze.get_cell(self.current_cell.x, self.current_cell.y + 1)
        elif direction == "W":
            return self.maze.get_cell(self.current_cell.x - 1, self.current_cell.y)